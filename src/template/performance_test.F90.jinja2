{#  _                    _     __               #}
{# / \ ._   _  ._  |\/| |_)   (_ _|_     |_   _ #}
{# \_/ |_) (/_ | | |  | |     __) |_ |_| |_) _> #}
{#     |                                        #}

{% if openmp_api_call or multiple_devices %}
#ifndef _OPENMP
{% endif %}

{% if openmp_api_call and single("teams") %}
FUNCTION omp_get_num_teams() RESULT(i)
  INTEGER :: i
  i = 1
END FUNCTION omp_get_num_teams
{% endif %}

{% if single("teams") %}
SUBROUTINE omp_set_num_teams(i)
    integer, intent(in) :: i
    IF (i /= 0) CONTINUE
END SUBROUTINE omp_set_num_teams
{% endif %}

{% if openmp_api_call and single("parallel") %}
FUNCTION omp_get_num_threads() RESULT(i)
  INTEGER :: i
  i = 1
END FUNCTION omp_get_num_threads
{% endif %}

{% if multiple_devices %}
FUNCTION omp_get_num_devices() RESULT(i)
  INTEGER :: i
  i = 1
END FUNCTION omp_get_num_devices
{% endif %}

{% if openmp_api_call or multiple_devices %}
#endif
{% endif %}

{% if test_type == 'empty_function_latency' %}
SUBROUTINE empty_function()
END SUBROUTINE empty_function
{% endif %}

{# ___  ___      _        ______                _   _              #}
{# |  \/  |     (_)       |  ___|              | | (_)             #}
{# | .  . | __ _ _ _ __   | |_ _   _ _ __   ___| |_ _  ___  _ __   #}
{# | |\/| |/ _\` | | '_ \ |  _| | | | '_ \ / __| __| |/ _ \| '_ \  #}
{# | |  | | (_| | | | | | | | | |_| | | | | (__| |_| | (_) | | | | #}
{# \_|  |_/\__,_|_|_| |_| \_|  \__,_|_| |_|\___|\__|_|\___/|_| |_| #}
{#                                                                 #}

{# Fortran 2003 restrict the size identifiers to 63 characters #}
{# I don't want to talk (or support) older version... #}
{# "Be the Change You Wish To See in the World: #}

{% if name|length <= 63 %}
PROGRAM {{name}}
{% else %}
!{{name}}
PROGRAM main
{% endif %}

{#                               _                                   #}
{# \  / _. ._ o  _. |_  |  _    | \  _   _ |  _. ._ _. _|_ o  _  ._  #}
{#  \/ (_| |  | (_| |_) | (/_   |_/ (/_ (_ | (_| | (_|  |_ | (_) | | #}
{#                                                                   #}

{# OpenMP libs are required for all performance codes #}
  USE OMP_LIB
  implicit none

  DOUBLE PRECISION :: v_start, v_end, v_elapsed
  INTEGER :: repeat_call
{% if test_type == 'get_thread_num_latency' %}
  INTEGER :: localid
{% elif test_type == 'matrix_decomposition' %}
  {{T}}, DIMENSION({{matrix_size}}, {{matrix_size}}) :: mat
  {% for row in range(matrix_size) %}
    {% for col in range(matrix_size) %}
  {{T}} :: n_{{row}}_{{col}}
    {% endfor %}
  {% endfor %}
{% elif test_type == 'branches' %}
  {% for r in range(branch_depth) %}
  INTEGER :: cond_{{r}} = {{r % 2}}
  {% endfor %}
{% endif %}
{% for counter in regions_counter | unique %}
  {{T}} :: {{counter}}
{% endfor %}

{% for loop_constructs in regions_associated_loop %}
{% for loop_  in loop_constructs %}
  INTEGER :: {{ loop_.N }} = {{ loop_.v }}
  INTEGER :: {{ loop_.i }}
{% endfor %}
{% endfor %}

{% if single("teams") %}
  CALL omp_set_num_teams({{loop_tripcount}})
{% endif %}

{% if test_type == 'matrix_decomposition' %}
  CALL random_number(mat)
{% endif %}

{# start the timer #}
  v_start = omp_get_wtime()

{#                      _                          #}
{# |   _   _  ._   _   |_) ._ _  |  _   _       _  #}
{# |_ (_) (_) |_) _>   |   | (_) | (_) (_| |_| (/_ #}
{#            |                         _|         #}

{% for region, loop_constructs, region_additional_pragma, counter in zip(l_nested_constructs_ironed_out, regions_associated_loop, regions_additional_pragma,regions_counter) %}
{% filter indent(width=2*loop.index) %}
   {# In the case of 'local' test, we use only one counter in the outermost enclosing scope #}
   {% if loop.first %}
{{counter}} = {%if test_type.endswith('_max') %} 1 {%else%} 0 {%endif%} 
   {% endif %}

   {# if it's the inner-most loop, then add the data statements for localid for get_thread_id #}
   {% if test_type == 'get_thread_num_latency' and loop.last %}
     {% for pragma, additional_pragma in zip(region, region_additional_pragma) %}
!$OMP {{pragma | replace("for","do") | upper() }} {{additional_pragma}} {% if loop.last %} private(localid) {% endif %}
     {% endfor %}
   {% else %}
     {% for pragma, additional_pragma in zip(region, region_additional_pragma) %}
!$OMP {{pragma | replace("for","do") | upper() }} {{additional_pragma}} 
     {% endfor %}
   {% endif %}

   {% for loop_  in loop_constructs %}
DO {{loop_.i}} = 1, {{loop_.N}}
   {% endfor %}
{% endfilter %}
{% endfor %}

{#                      _                         #}
{# |   _   _  ._   _   |_ ._  o |  _   _       _  #}
{# |_ (_) (_) |_) _>   |_ |_) | | (_) (_| |_| (/_ #}
{#            |           |            _|         #}
{% for region, loop_constructs, increments in zip(l_nested_constructs_ironed_out, regions_associated_loop, regions_increment) | reverse %}
   {% filter indent(width=2*(loop.revindex+1)) %}
      {# In the case of 'local' test, we increment the counter only in the inner most enclosing scope #}
      {% if loop.first %}
        {# launch commands go in here #}
DO repeat_call = 0, {{ repeatcount }}
        {% if test_type == 'empty_function_latency' %}
  CALL empty_function()
        {% elif test_type == 'get_thread_num_latency' %}
  localid = omp_get_thread_num()
        {% elif test_type == 'matrix_decomposition' %}
            {% for row in range(matrix_size) %}
                {% for col in range(matrix_size) %}
  n_{{row}}_{{col}} = mat({{row}},{{col}})
                {% endfor %}
            {% endfor %}
        {% elif test_type == 'branches' %}
  {{nested_ifs_f90()}}
        {% endif %}
END DO
      {% endif %}

   {% endfilter %}

   {# The closing brackets are indented by one less level #}
   {% filter indent(width=2*loop.revindex) %}
      {% for loop_  in loop_constructs %}
END DO
      {% endfor %}
   {% endfilter %}

   {% filter indent(width=2*loop.revindex) %}
         {% for pragma in region | reverse %}
             {% if paired_pragmas or not pragma.has_construct("loop-associated") %}
!$OMP END {{pragma | replace("for","do") | upper}}
             {% endif %}
         {% endfor %}
   {% endfilter %}
{% endfor %}

{# end the timer #}
  v_end = omp_get_wtime()


{#                                   #}
{# \  / _. | o  _|  _. _|_ o  _  ._  #}
{#  \/ (_| | | (_| (_|  |_ | (_) | | #}
{#                                   #}

{# https://tldp.org/LDP/abs/html/exitcodes.html, we choose 112 #}
{# To follow the standard we should use ERROR STOP. But it's a Fortran 2008 feature...#}
{# That may cause portabilities issue #}
  PRINT *, "Per-call Time: ", (v_end - v_start) / {{ repeatcount }}, " s"

{% if name|length <= 63 %}
END PROGRAM {{name}}
{% else %}
END PROGRAM main
{% endif %}
